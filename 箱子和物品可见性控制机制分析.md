# ç®±å­å’Œç‰©å“å¯è§æ€§æ§åˆ¶æœºåˆ¶åˆ†æ

## ğŸ“‹ æ ¸å¿ƒç»„ä»¶

### 1. **SetActiveByCondition** ç»„ä»¶
æ§åˆ¶ GameObject çš„æ¿€æ´»çŠ¶æ€ï¼ˆ`SetActive(true/false)`ï¼‰

**å·¥ä½œåŸç†**:
```csharp
public class SetActiveByCondition : MonoBehaviour
{
    public GameObject targetObject;           // è¦æ§åˆ¶çš„ç›®æ ‡å¯¹è±¡
    public bool inverse;                      // æ˜¯å¦åè½¬æ¡ä»¶ç»“æœ
    public List<Condition> conditions;        // æ¡ä»¶åˆ—è¡¨
    public bool update;                       // æ˜¯å¦æŒç»­æ£€æŸ¥
    private float checkTimeSpace = 1f;        // æ£€æŸ¥é—´éš”ï¼ˆ1ç§’ï¼‰
    
    private void Update()
    {
        // åœ¨å…³å¡åˆå§‹åŒ–åæ‰æ£€æŸ¥
        if (!LevelManager.LevelInited && this.requireLevelInited)
            return;
            
        // è¯„ä¼°æ‰€æœ‰æ¡ä»¶
        bool satisfied = conditions.Satisfied();
        if (inverse)
            satisfied = !satisfied;
            
        targetObject.SetActive(satisfied);
        
        // å¦‚æœéœ€è¦æŒç»­æ›´æ–°ï¼Œ1ç§’åå†æ¬¡æ£€æŸ¥
        if (update)
            CheckAndLoop();
            
        enabled = false; // å•æ¬¡æ£€æŸ¥åç¦ç”¨è‡ªå·±
    }
}
```

**æ¡ä»¶è¯„ä¼°é€»è¾‘**:
```csharp
// æ‰€æœ‰æ¡ä»¶éƒ½å¿…é¡»æ»¡è¶³ï¼ˆAND é€»è¾‘ï¼‰
public static bool Satisfied(this IEnumerable<Condition> conditions)
{
    foreach (Condition condition in conditions)
    {
        if (condition == null) continue;
        if (!condition.Evaluate())  // ä»»ä½•ä¸€ä¸ªä¸æ»¡è¶³å°±è¿”å› false
            return false;
    }
    return true;
}
```

---

### 2. **Condition** åŸºç±»å’Œæ´¾ç”Ÿç±»
å®šä¹‰å„ç§æ¡ä»¶åˆ¤æ–­é€»è¾‘

**åŸºç±»**:
```csharp
public class Condition : MonoBehaviour
{
    public virtual bool Evaluate()
    {
        return false;
    }
}
```

**å¸¸è§æ´¾ç”Ÿç±»**:

#### ä»»åŠ¡ç›¸å…³:
- **RequireQuestsActive**: ä»»åŠ¡æ¿€æ´»æ—¶æ»¡è¶³
  ```csharp
  public override bool Evaluate()
  {
      return QuestManager.AreQuestsActive(requiredQuestIDs);
  }
  ```

- **RequireQuestsFinished**: ä»»åŠ¡å®Œæˆæ—¶æ»¡è¶³
  ```csharp
  public override bool Evaluate()
  {
      return QuestManager.AreQuestFinished(requiredQuestIDs);
  }
  ```

#### é…æ–¹/è“å›¾ç›¸å…³:
- **RequireFormulaUnlocked**: é…æ–¹è§£é”æ—¶æ»¡è¶³
  ```csharp
  public override bool Evaluate()
  {
      return CraftingManager.IsFormulaUnlocked(formulaID);
  }
  ```

- **RequirePerkUnlocked**: æŠ€èƒ½è§£é”æ—¶æ»¡è¶³

#### å…¶ä»–:
- **Condition_TimeOfDay**: ç‰¹å®šæ—¶é—´æ®µ
- **Condition_CharacterLevel**: è§’è‰²ç­‰çº§è¦æ±‚
- **Condition_RaidDead**: RAID å¤±è´¥çŠ¶æ€
- **Condition_HasBeenToScene**: è®¿é—®è¿‡ç‰¹å®šåœºæ™¯
- **RequireWeathers**: ç‰¹å®šå¤©æ°”
- **RequireBeaconUnlocked**: ä¿¡æ ‡è§£é”
- **RequireEnemyKilled**: æ•Œäººè¢«å‡»æ€

---

### 3. **LootBoxLoader** ç»„ä»¶
æ§åˆ¶ç®±å­çš„ç”Ÿæˆå’Œå†…å®¹

**å…³é”®åŠŸèƒ½**:

#### A. éšæœºæ¿€æ´»ï¼ˆæ¦‚ç‡ç”Ÿæˆï¼‰
```csharp
[Range(0f, 1f)]
private float activeChance = 1f;  // ç®±å­ç”Ÿæˆæ¦‚ç‡

private void RandomActive()
{
    int key = GetKey();  // åŸºäºä½ç½®çš„å”¯ä¸€Key
    
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç¼“å­˜å†³ç­–
    if (MultiSceneCore.Instance.inLevelData.TryGetValue(key, out obj))
    {
        flag = (bool)obj;  // ä½¿ç”¨ç¼“å­˜çš„æ¿€æ´»çŠ¶æ€
    }
    else
    {
        // ç¬¬ä¸€æ¬¡ç”Ÿæˆï¼Œæ·éª°å­å†³å®š
        flag = Random.Range(0f, 1f) < activeChance;
        MultiSceneCore.Instance.inLevelData.Add(key, flag);  // ç¼“å­˜å†³ç­–
    }
    
    gameObject.SetActive(flag);  // è®¾ç½®æ¿€æ´»çŠ¶æ€
}
```

**é‡è¦ç‰¹æ€§**:
- ä½¿ç”¨ `inLevelData` ç¼“å­˜æ¿€æ´»çŠ¶æ€ï¼ˆåŒä¸€å…³å¡å†…ä¿æŒä¸€è‡´ï¼‰
- ä¸åŒå…³å¡ã€ä¸åŒå­˜æ¡£å¯èƒ½æœ‰ä¸åŒçš„ç”Ÿæˆç»“æœ
- `activeChance = 0.5` è¡¨ç¤º 50% æ¦‚ç‡ç”Ÿæˆ

#### B. ç‰©å“ç”Ÿæˆ
```csharp
public async UniTask Setup()
{
    // éšæœºç”Ÿæˆç‰©å“æ•°é‡
    int num = Random.Range(randomCount.x, randomCount.y) * LootboxItemCountMultiplier;
    
    // ç”Ÿæˆå›ºå®šç‰©å“ï¼ˆå¯é€‰ï¼‰
    if (Random.Range(0f, 1f) < fixedItemSpawnChance)
        list.AddRange(fixedItems);
    
    // ç”Ÿæˆéšæœºç‰©å“
    for (int i = 0; i < num; i++)
    {
        // ä»ç‰©å“æ± æˆ–æ ‡ç­¾æ± ä¸­éšæœºé€‰æ‹©
        // ...
    }
    
    // æ·»åŠ åˆ° Inventory
    foreach (int itemID in list)
    {
        Item item = await ItemAssetsCollection.InstantiateAsync(itemID);
        Inventory.AddItem(item);
    }
    
    Inventory.Loading = false;
    _lootBox.CheckHideIfEmpty();  // æ£€æŸ¥æ˜¯å¦ä¸ºç©ºç®±å­
}
```

---

## ğŸ¯ ç®±å­/ç‰©å“ä¸å¯è§çš„å…¸å‹åœºæ™¯

### åœºæ™¯ 1: ä»»åŠ¡é”å®šçš„ç®±å­
```
GameObject: "QuestLootbox"
â”œâ”€ InteractableLootbox
â”œâ”€ LootBoxLoader
â”‚  â””â”€ activeChance = 1.0
â””â”€ SetActiveByCondition
   â”œâ”€ targetObject = this.gameObject
   â”œâ”€ inverse = false
   â”œâ”€ update = true
   â””â”€ conditions:
      â””â”€ RequireQuestsActive
         â””â”€ requiredQuestIDs = [101, 102]
```

**è¡Œä¸º**:
- ä»»åŠ¡ 101 å’Œ 102 éƒ½æ¿€æ´»æ—¶ â†’ ç®±å­å¯è§
- ä»»åŠ¡æœªå¼€å§‹æˆ–å·²å®Œæˆ â†’ ç®±å­ä¸å¯è§
- æ¯ç§’æ£€æŸ¥ä¸€æ¬¡ä»»åŠ¡çŠ¶æ€ï¼ˆ`update = true`ï¼‰

---

### åœºæ™¯ 2: è“å›¾é”å®šçš„ç‰©å“
```
GameObject: "BlueprintItem"
â”œâ”€ DuckovItemAgent (pickUpç±»å‹)
â”œâ”€ Item
â””â”€ SetActiveByCondition
   â”œâ”€ targetObject = this.gameObject
   â”œâ”€ inverse = false
   â””â”€ conditions:
      â””â”€ RequireFormulaUnlocked
         â””â”€ formulaID = "GunBlueprint_AK47"
```

**è¡Œä¸º**:
- ç©å®¶æœªè§£é”é…æ–¹ â†’ ç‰©å“ä¸å¯è§
- ç©å®¶è§£é”é…æ–¹å â†’ ç‰©å“å¯è§
- å…¨å±€åªèƒ½æ¡ä¸€æ¬¡ï¼ˆæ¡èµ·åè‡ªåŠ¨é”€æ¯ï¼‰

---

### åœºæ™¯ 3: æ¦‚ç‡ç”Ÿæˆçš„ç®±å­
```
GameObject: "RandomLootbox"
â”œâ”€ InteractableLootbox
â””â”€ LootBoxLoader
   â””â”€ activeChance = 0.3
```

**è¡Œä¸º**:
- å…³å¡åŠ è½½æ—¶ 30% æ¦‚ç‡ç”Ÿæˆ
- ä¸€æ—¦å†³å®šä¸ç”Ÿæˆï¼Œæ•´ä¸ªå…³å¡å‘¨æœŸå†…éƒ½ä¸ä¼šå‡ºç°
- é‡æ–°åŠ è½½å…³å¡å¯èƒ½æ”¹å˜ç”Ÿæˆç»“æœ

---

### åœºæ™¯ 4: å¤šé‡æ¡ä»¶å¤åˆ
```
GameObject: "AdvancedLootbox"
â”œâ”€ InteractableLootbox
â”œâ”€ LootBoxLoader
â”‚  â””â”€ activeChance = 0.5
â””â”€ SetActiveByCondition
   â”œâ”€ conditions:
   â”‚  â”œâ”€ RequireQuestsFinished [201]
   â”‚  â”œâ”€ Condition_CharacterLevel (min = 10)
   â”‚  â””â”€ RequireBeaconUnlocked
   â””â”€ update = false
```

**è¡Œä¸º**:
1. é¦–å…ˆ 50% æ¦‚ç‡å†³å®šæ˜¯å¦ç”Ÿæˆï¼ˆLootBoxLoaderï¼‰
2. å¦‚æœç”Ÿæˆï¼Œæ£€æŸ¥ä¸‰ä¸ªæ¡ä»¶ï¼š
   - ä»»åŠ¡ 201 å¿…é¡»å®Œæˆ
   - è§’è‰²ç­‰çº§ â‰¥ 10
   - ä¿¡æ ‡å·²è§£é”
3. æ‰€æœ‰æ¡ä»¶æ»¡è¶³ â†’ ç®±å­å¯è§

---

## ğŸ” ä¸ºä»€ä¹ˆæˆ‘ä»¬çš„è¿‡æ»¤è¿˜ä¸å¤Ÿï¼Ÿ

### å½“å‰è¿‡æ»¤é€»è¾‘:
```csharp
// LootboxDataCollector.cs
if (!lootbox.gameObject.activeInHierarchy)  // âœ… èƒ½è¿‡æ»¤
    continue;

if (!lootbox.enabled)  // âœ… èƒ½è¿‡æ»¤
    continue;
```

### é—®é¢˜åˆ†æ:

#### é—®é¢˜ 1: SetActiveByCondition çš„å»¶è¿Ÿç”Ÿæ•ˆ
```csharp
private void Update()
{
    if (!LevelManager.LevelInited && this.requireLevelInited)
        return;  // å…³å¡æœªåˆå§‹åŒ–æ—¶ä¸æ£€æŸ¥
        
    this.Set();  // ç¬¬ä¸€æ¬¡è®¾ç½®æ¿€æ´»çŠ¶æ€
    enabled = false;  // ç¦ç”¨è‡ªå·±
}
```

**æ—¶åºé—®é¢˜**:
```
1. å…³å¡å¼€å§‹åŠ è½½
2. LootboxDataCollector.ScanExistingLootboxes() æ‰§è¡Œ  â† æ­¤æ—¶ GameObject å¯èƒ½è¿˜æ˜¯ active
3. LevelManager.LevelInited = true
4. SetActiveByCondition.Update() æ‰§è¡Œ  â† ç°åœ¨æ‰è®¾ç½® active çŠ¶æ€
5. ç®±å­è¢«ç¦ç”¨ï¼Œä½†å·²ç»è¢«è¿½è¸ªäº†
```

#### é—®é¢˜ 2: update = true çš„åŠ¨æ€å˜åŒ–
```csharp
if (this.update)
{
    CheckAndLoop();  // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
}
```

**åŠ¨æ€é—®é¢˜**:
- ä»»åŠ¡çŠ¶æ€éšæ—¶å¯èƒ½æ”¹å˜
- ç®±å­å¯èƒ½åœ¨æ¸¸æˆè¿‡ç¨‹ä¸­åŠ¨æ€å‡ºç°/æ¶ˆå¤±
- æˆ‘ä»¬çš„æ‰«æåªåœ¨å…³å¡åˆå§‹åŒ–æ—¶æ‰§è¡Œä¸€æ¬¡

---

## ğŸ’¡ å»ºè®®çš„å®Œæ•´è§£å†³æ–¹æ¡ˆ

### æ–¹æ¡ˆ A: å»¶è¿Ÿæ‰«æï¼ˆç®€å•ï¼‰
```csharp
private void ScanExistingLootboxes()
{
    // ç­‰å¾…å…³å¡å®Œå…¨åˆå§‹åŒ–
    await UniTask.WaitUntil(() => LevelManager.LevelInited);
    
    // å†ç­‰ä¸€å¸§ï¼Œç¡®ä¿æ‰€æœ‰ SetActiveByCondition éƒ½æ‰§è¡Œå®Œ
    await UniTask.Yield();
    
    // ç°åœ¨å¼€å§‹æ‰«æ
    var allLootboxes = FindObjectsOfType<InteractableLootbox>();
    foreach (var lootbox in allLootboxes)
    {
        if (!lootbox.gameObject.activeInHierarchy)
            continue;  // ç°åœ¨èƒ½æ­£ç¡®è¿‡æ»¤äº†
        
        ProcessLootbox(lootbox);
    }
}
```

### æ–¹æ¡ˆ B: ç›‘å¬åŠ¨æ€å˜åŒ–ï¼ˆå®Œæ•´ï¼‰
```csharp
// 1. åœ¨ LootboxDataCollector ä¸­æ·»åŠ å®šæœŸæ£€æŸ¥
private async UniTaskVoid MonitorLootboxVisibility()
{
    while (_isInitialized)
    {
        await UniTask.WaitForSeconds(1f);  // æ¯ç§’æ£€æŸ¥
        
        // æ£€æŸ¥æ‰€æœ‰å·²è¿½è¸ªçš„ç®±å­
        var toRemove = new List<InteractableLootbox>();
        foreach (var kvp in _trackedLootboxes)
        {
            var lootbox = kvp.Key;
            if (lootbox == null || !lootbox.gameObject.activeInHierarchy)
            {
                toRemove.Add(lootbox);
            }
        }
        
        // ç§»é™¤ä¸å¯è§çš„ç®±å­
        foreach (var lootbox in toRemove)
        {
            RemoveLootbox(lootbox);
        }
        
        // æ‰«ææ–°å‡ºç°çš„ç®±å­
        ScanForNewLootboxes();
    }
}

// 2. åœ¨ MinimapMarkerService ä¸­è®¢é˜… LootboxRemovedEvent
```

### æ–¹æ¡ˆ C: æ£€æŸ¥ SetActiveByCondition ç»„ä»¶ï¼ˆç²¾ç¡®ï¼‰
```csharp
private bool ShouldTrackLootbox(InteractableLootbox lootbox)
{
    // åŸºç¡€æ£€æŸ¥
    if (lootbox == null || !lootbox.gameObject.activeInHierarchy)
        return false;
    
    if (!lootbox.enabled)
        return false;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ SetActiveByCondition ç»„ä»¶
    var conditionComponent = lootbox.GetComponent<SetActiveByCondition>();
    if (conditionComponent != null)
    {
        // æ‰‹åŠ¨è¯„ä¼°æ¡ä»¶
        bool satisfied = conditionComponent.conditions.Satisfied();
        if (conditionComponent.inverse)
            satisfied = !satisfied;
        
        if (!satisfied)
        {
            _logger.Debug($"ç®±å­æ¡ä»¶ä¸æ»¡è¶³: {lootbox.name}");
            return false;
        }
    }
    
    // æ£€æŸ¥ LootBoxLoader çš„æ¦‚ç‡ç”Ÿæˆ
    var loader = lootbox.GetComponent<LootBoxLoader>();
    if (loader != null)
    {
        // activeChance å·²ç»åœ¨ Awake ä¸­å¤„ç†ï¼Œè¿™é‡Œåªæ£€æŸ¥ç»“æœ
        if (!lootbox.gameObject.activeSelf)
            return false;
    }
    
    return true;
}
```

---

## ğŸ“Š æ¨èå®æ–½æ–¹æ¡ˆ

ç»“åˆç®€å•æ€§å’Œæœ‰æ•ˆæ€§ï¼Œæ¨è **æ–¹æ¡ˆ A + ä¼˜åŒ–çš„åˆå§‹æ£€æŸ¥**:

```csharp
// 1. å»¶è¿Ÿåˆå§‹æ‰«æ
public async void Initialize()
{
    // ç­‰å¾…å…³å¡åˆå§‹åŒ–
    await UniTask.WaitUntil(() => LevelManager.LevelInited);
    
    // ç­‰å¾…ä¸€å¸§è®©æ‰€æœ‰ SetActiveByCondition æ‰§è¡Œ
    await UniTask.Yield();
    
    // ç°åœ¨æ‰«æ
    ScanExistingLootboxes();
    
    // è®¢é˜… Hook
    LootboxSpawnHook.OnLootboxSpawned += HandleLootboxSpawned;
}

// 2. åŠ¨æ€ç”Ÿæˆçš„ç®±å­æ£€æŸ¥
private void HandleLootboxSpawned(InteractableLootbox lootbox)
{
    if (lootbox == null || !lootbox.gameObject.activeInHierarchy)
        return;
    
    if (!lootbox.enabled)
        return;
    
    // å¯¹äºåŠ¨æ€ç”Ÿæˆçš„ç®±å­ï¼Œç­‰å¾…ä¸€å¸§å†æ£€æŸ¥
    await UniTask.Yield();
    
    if (!lootbox.gameObject.activeInHierarchy)
        return;  // å¯èƒ½è¢« SetActiveByCondition ç¦ç”¨äº†
    
    ProcessLootbox(lootbox);
}
```

è¿™æ ·å¯ä»¥ï¼š
- âœ… è¿‡æ»¤æ‰ä»»åŠ¡é”å®šçš„ç®±å­
- âœ… è¿‡æ»¤æ‰è“å›¾é”å®šçš„ç‰©å“
- âœ… è¿‡æ»¤æ‰æ¦‚ç‡æœªç”Ÿæˆçš„ç®±å­
- âœ… è¿‡æ»¤æ‰å¤šé‡æ¡ä»¶ä¸æ»¡è¶³çš„å¯¹è±¡
- âœ… ä¿æŒä»£ç ç®€æ´ï¼Œæ€§èƒ½å¼€é”€å°
